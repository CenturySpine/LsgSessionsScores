-- Supabase (Postgres) schema mirroring the current Room schema (AppDatabase v10)
-- Project: LsgScores
-- Note: Room currently has no foreign key constraints (see MIGRATION_6_7). This DDL mirrors that.
-- If you later want server-side referential integrity, see the commented FK examples below.

-- Recommended extension for JSONB and UUID utilities (installed by default on Supabase)
-- create extension if not exists pgcrypto;

-- 1) Cities
create table if not exists public.cities (
  id bigint generated by default as identity primary key,
  name text not null
);
create unique index if not exists idx_cities_name on public.cities(name);

-- 2) Game zones
create table if not exists public.game_zones (
  id bigint generated by default as identity primary key,
  name text not null,
  cityId bigint not null default 1
);
create unique index if not exists idx_game_zones_name on public.game_zones(name);

-- 3) Players
create table if not exists public.players (
  id bigint generated by default as identity primary key,
  name text not null,
  photoUri text,
  cityId bigint not null default 1
);

-- 4) Scoring modes
create table if not exists public.scoring_modes (
  id integer generated by default as identity primary key,
  name text not null,
  description text not null
);

-- 5) Holes
create table if not exists public.holes (
  id bigint generated by default as identity primary key,
  name text not null,
  gameZoneId bigint not null,
  description text,
  distance integer,
  par integer not null,
  startPhotoUri text,
  endPhotoUri text
);
create index if not exists idx_holes_gameZoneId on public.holes(gameZoneId);

-- 6) Sessions
-- Room stores LocalDateTime as TEXT (ISO_LOCAL_DATE_TIME). We mirror that here for a lossless migration.
-- You can later switch to timestamptz with a migration if desired.
create table if not exists public.sessions (
  id bigint generated by default as identity primary key,
  dateTime text not null,
  endDateTime text,
  sessionType text not null, -- values from enum SessionType: INDIVIDUAL, TEAM
  scoringModeId integer not null,
  gameZoneId bigint not null,
  comment text,
  isOngoing boolean not null default false,
  weatherData jsonb, -- Room keeps TEXT JSON; jsonb is a natural fit in Postgres
  cityId bigint not null default 1
);
create index if not exists idx_sessions_gameZoneId on public.sessions(gameZoneId);

-- 7) Teams
create table if not exists public.teams (
  id bigint generated by default as identity primary key,
  sessionId bigint not null,
  player1Id bigint not null,
  player2Id bigint
);

-- 8) Played holes
create table if not exists public.played_holes (
  id bigint generated by default as identity primary key,
  sessionId bigint not null,
  holeId bigint not null,
  gameModeId integer not null,
  position integer not null
);

-- 9) Played hole scores
create table if not exists public.played_hole_scores (
  id bigint generated by default as identity primary key,
  playedHoleId bigint not null,
  teamId bigint not null,
  strokes integer not null
);

-- Optional: add foreign key constraints (commented to mirror Room's current behavior)
-- alter table public.game_zones
--   add constraint fk_game_zones_city foreign key (cityId) references public.cities(id) on delete restrict;
-- alter table public.players
--   add constraint fk_players_city foreign key (cityId) references public.cities(id) on delete restrict;
-- alter table public.holes
--   add constraint fk_holes_game_zone foreign key (gameZoneId) references public.game_zones(id) on delete cascade;
-- alter table public.sessions
--   add constraint fk_sessions_game_zone foreign key (gameZoneId) references public.game_zones(id) on delete restrict,
--   add constraint fk_sessions_scoring_mode foreign key (scoringModeId) references public.scoring_modes(id) on delete restrict,
--   add constraint fk_sessions_city foreign key (cityId) references public.cities(id) on delete restrict;
-- alter table public.teams
--   add constraint fk_teams_session foreign key (sessionId) references public.sessions(id) on delete cascade,
--   add constraint fk_teams_player1 foreign key (player1Id) references public.players(id) on delete restrict,
--   add constraint fk_teams_player2 foreign key (player2Id) references public.players(id) on delete restrict;
-- alter table public.played_holes
--   add constraint fk_played_holes_session foreign key (sessionId) references public.sessions(id) on delete cascade,
--   add constraint fk_played_holes_hole foreign key (holeId) references public.holes(id) on delete restrict;
-- alter table public.played_hole_scores
--   add constraint fk_played_hole_scores_played_hole foreign key (playedHoleId) references public.played_holes(id) on delete cascade,
--   add constraint fk_played_hole_scores_team foreign key (teamId) references public.teams(id) on delete cascade;

-- RLS scaffolding (disabled by default). Uncomment and adapt if you adopt multi-user auth.
-- alter table public.cities enable row level security;
-- alter table public.game_zones enable row level security;
-- alter table public.players enable row level security;
-- alter table public.scoring_modes enable row level security;
-- alter table public.holes enable row level security;
-- alter table public.sessions enable row level security;
-- alter table public.teams enable row level security;
-- alter table public.played_holes enable row level security;
-- alter table public.played_hole_scores enable row level security;
-- Example policy pattern once you add a user_id column and Auth:
-- create policy "Owner can manage own" on public.sessions for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Seed default city (Room migration set default city id=1 to 'Lyon')
insert into public.cities(id, name)
values (1, 'Lyon')
on conflict (id) do nothing;
